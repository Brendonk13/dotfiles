#!/usr/bin/env bash

[ -f "$HOME/dotfiles/bashh/from_online.sh" ] && source "$HOME/dotfiles/bashh/from_online.sh"

function changeDirAndShow() {
    cd "$1" && ls -A
}


#think best solution is to just loop over both out, lss at same time 
# and concat each pair ala python zip printing as I go :(

#dankLS() {
#    # info="$(lsd --group-dirs first -l --total-size | awk '{print $11}' | xargs file)"
#    declare -a ls_output
#    ls_output="$(lsd --group-dirs first -l --total-size --blocks size,name)"
#    info="$(echo -e $ls_output awk '{print $3}' | xargs file)"
#    for ls_out in "${ls_output[@]}"; do
#    done
#    #-l --blocks size,name'
#}
# out="$(lss | awk '{print $3}' | xargs file | awk '{for (i=2; i<NF; i++) printf $i " "; print $NF}')"
# lmerge <(echo -e "$out") <(lsd -l --blocks size,name) | head | paste - -


fuzzyDeleteBranch() {
    # last column is the name we are looking for
    chosen_branch="$(git branch -a | fzf | awk '{print $NF}')"
    [[ "$chosen_branch" = "" ]] && return

    if [[ "$chosen_branch" = remotes* ]]; then
        # delimited by /  only keep 3rd field of remotes/origin/branch_name
        just_name="$(echo "$chosen_branch" | cut -d '/' -f3)"
    else
        just_name="$chosen_branch"
    fi
    # delete the local branch
    git branch -D "$just_name"
    # delete remote branch
    [[ "$chosen_branch" = remotes* ]] && git push origin --delete "$just_name"
}


# this will just push to origin current_branch
gpush() {
    # extract name of current branch from output, here first column is *
    current_branch="$(git branch -a | awk '{if ($1 ~ /\*/) print $NF}')"
    git push origin "$current_branch"
}


# ------------------------------- Search For input in "fasd -Rfl" file list or from $PWD----------------------------
alias sf=ssf
ssf() {
    rg_command='rg --column --line-number --no-heading --fixed-strings --color "always"'
    search=""
    printf -v search "%q" "$*"
    if [ $# -lt 1 ]; then
        recents="$(fasd -Rfl "$1")"
        fils="$(echo -e $recents | awk '!/(^.*\.mp4$)/{print}')"
        files=`eval $rg_command $search "{$fils[*]}" | fzf --ansi --multi --reverse | awk -F ':' '{print $1":"$2":"$3}'`
    else
        files=`eval $rg_command $search | fzf --ansi --multi --reverse | awk -F ':' '{print $1":"$2":"$3}'`
    fi

    [[ -n "$files" ]] && $VISUAL "$files"
}

# this is sick cuz it will open shit in vim also
# neeeeed to hook this up to rofi!!!
# but rofi already has modes for these things ..
# desired functionality: open an img/pdf in terminal without it being associated with the terminal
# ie I can close the terminal and the img/pdf will persist
alias o=fuzzy_xdgopen
fuzzy_xdgopen() {
    [ $# -gt 0 ] && fasd -f "$*" | xargs -0 xdg-open && return
    local file
    # setsid opens the file in a new session so the process will survive the parent process.
    file="$(fasd -Rfl "$1" | fzf -1 -0 --no-sort +m)" && setsid xdg-open "${file}"
}
[ -f "$HOME/.config/.fzf_setup.sh" ] && source "$HOME/.config/.fzf_setup.sh"


cht() {
    paste the general cheat sheet curl cmd in terminal
    echo 'use: cht.sh/java/"question"'
    echo -n 'curl cht.sh/ /"for loop"' | xclip -selection c
    echo 'just enter this command for way more cheat sheet info !!'
    sleep 0.1
    xdotool key ctrl+shift+v
}


# ------------------------------- follow moved files to the dest. folder ----------------------------
function mcd() {
    if [ "$#" -lt 2 ]; then
        echo "Input files and destination for this to work jeez."
        echo "Next time enter more than 1 argument: mcd files dest."
        return
    fi
    file_destination=${@:$#}
    num_files=$#

    # num_files is originally counting files and the destination dir
    # so shift one less time than $#
    num_files=$(($num_files - 1))

    while [ "$num_files" -gt 0 ]; do
        mv "$1" "$file_destination"
        num_files=$(($num_files - 1))
        shift
    done

    echo "";  echo " ----- NEW DIR CONTAINS:";
    cd "$file_destination"
    ls
    echo ""
}



#-------------------------------------------- fuzzy search arch/AUR repositories then download --------------------------------------------
function search_packages() {
    pac_manager="$1"
    if [ "$pac_manager" == "yay" ]; then
        # "$pac_manager" -S --noconfirm "$package_name"
        yay -Slq | fzf -m --preview 'yay -Si {1}'| xargs -ro yay -S --noconfirm
        # sudo not recommended for yay installs
    else
        pacman -Slq  | fzf -m --preview 'pacman -Si {1}' | xargs -ro sudo pacman -S --noconfirm
    #     sudo "$pac_manager" -S --noconfirm "$package_name"
    fi
}

# no more friggin error sound !!!
bind 'set bell-style none'


## SMARTER TAB-COMPLETION (Readline bindings) ##
#
# Perform file completion in a case insensitive fashion
bind "set completion-ignore-case on"

# Treat hyphens and underscores as equivalent
bind "set completion-map-case on"

# Display matches for ambiguous patterns at first tab press
bind "set show-all-if-ambiguous on"

# Don't record some commands -- who cares if they only show up once!
#export HISTIGNORE="&:[ ]*:exit:ls:history:clear"
