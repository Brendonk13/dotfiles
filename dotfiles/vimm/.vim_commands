
function! MarkWindowSwap()
  let g:markedWinNum = winnr()
endfunction

function! DoWindowSwap()
  "Mark destination
  let curNum = winnr()
  let curBuf = bufnr( "%" )
  exe g:markedWinNum . "wincmd w"
  "Switch to source and shuffle dest->source
  let markedBuf = bufnr( "%" )
  "Hide and open so that we aren't prompted and keep history
  exe 'hide buf' curBuf
  "Switch to dest and shuffle source->dest
  exe curNum . "wincmd w"
  "Hide and open so that we aren't prompted and keep history
  exe 'hide buf' markedBuf 
endfunction

" these functions come from https://stackoverflow.com/questions/2586984/how-can-i-swap-positions-of-two-open-files-in-splits-in-vim/4903681#4903681
nmap <silent> <leader>mw :call MarkWindowSwap()<CR>
nmap <silent> <leader>pw :call DoWindowSwap()<CR>



"from: https://stackoverflow.com/questions/44480829/how-to-copy-to-clipboard-in-vim-of-bash-on-windows
" just calls the native windows clip.exe function nice n simple
func! GetSelectedText()
  normal! gv"ty
  let result = getreg("t")
  return result
endfunc

"this is used by WSL
if executable("clip.exe")
  echom "clip.exe is executable"
  noremap <silent><leader>y :call system('clip.exe', GetSelectedText())<CR>
  " could/should add a cut command but who cares
  "noremap <C-X> :call system('clip.exe', GetSelectedText())<CR>gvx
endif

" this is used by my manjaro
if has('clipboard')
  nnoremap <silent><leader>y :normal! gv"+y<CR>
  vnoremap <silent><leader>y :normal! gv"+y<CR>
endif

" I would like to add a command that calls isort on my python files upon exiting them -- maybe this is overkill tho

let g:opened_neoterm = 0

function! ToggleDropDownNeoterm()
  " If neoterm is open, then save window height before closing
  " so that the next neoterm we open has the same height.
  if g:opened_neoterm

    " neoterm_buff_line is something like: 3 #a \".vimrc\" line 10
    redir => neoterm_buff_line
      silent! execute "filter /neoterm/ ls"
    redir END

    " buff num is first item when u do :ls
    let neoterm_buff_num = split(neoterm_buff_line)[0]

    " get the unique window id from the buffer number
    let neoterm_win_id = win_findbuf(neoterm_buff_num)[0]

    " get window height of open neoterm from it's window id
    let neoterm_win_height = winheight(neoterm_win_id)
    " echom \"neoterm buff num: \" . neoterm_buff_num
    " echom \"the win_id is: \" . neoterm_win_id
    " echom \"it's height: \" . neoterm_win_height

    let g:neoterm_size = neoterm_win_height

    let g:opened_neoterm = 0
    " now close the neoterm window
    Ttoggle
  else
    let g:opened_neoterm = 1
    Ttoggle
  endif
endfunction


" popup windows, stolen from a long ways down this: https://github.com/junegunn/fzf.vim/issues/821

fu s:snr() abort
    return matchstr(expand('<sfile>'), '.*\zs<SNR>\d\+_')
endfu
let s:snr = get(s:, 'snr', s:snr())
let g:fzf_layout = {'window': 'call '..s:snr..'fzf_window(0.92, 0.7, "Comment")'}

fu s:fzf_window(width, height, border_highlight) abort
    let width = float2nr(&columns * a:width)
    let height = float2nr(&lines * a:height)
    let row = float2nr((&lines - height) / 2)
    let col = float2nr((&columns - width) / 2)
    let top = '┌' . repeat('─', width - 2) . '┐'
    let mid = '│' . repeat(' ', width - 2) . '│'
    let bot = '└' . repeat('─', width - 2) . '┘'
    let border = [top] + repeat([mid], height - 2) + [bot]
    if has('nvim')
        let frame = s:create_float(a:border_highlight, {
            \ 'row': row,
            \ 'col': col,
            \ 'width': width,
            \ 'height': height,
            \ })
        call nvim_buf_set_lines(frame, 0, -1, v:true, border)
        call s:create_float('Normal', {
            \ 'row': row + 1,
            \ 'col': col + 2,
            \ 'width': width - 4,
            \ 'height': height - 2,
            \ })
        exe 'au BufWipeout <buffer> bw '..frame
    else
        let frame = s:create_popup_window(a:border_highlight, {
            \ 'line': row,
            \ 'col': col,
            \ 'width': width,
            \ 'height': height,
            \ 'is_frame': 1,
            \ })
        call setbufline(frame, 1, border)
        call s:create_popup_window('Normal', {
            \ 'line': row + 1,
            \ 'col': col + 2,
            \ 'width': width - 4,
            \ 'height': height - 2,
            \ })
    endif
endfu

fu s:create_float(hl, opts) abort
    let buf = nvim_create_buf(v:false, v:true)
    let opts = extend({'relative': 'editor', 'style': 'minimal'}, a:opts)
    let win = nvim_open_win(buf, v:true, opts)
    call setwinvar(win, '&winhighlight', 'NormalFloat:'..a:hl)
    return buf
endfu

fu s:create_popup_window(hl, opts) abort
    if has_key(a:opts, 'is_frame')
        let id = popup_create('', #{
            \ line: a:opts.line,
            \ col: a:opts.col,
            \ minwidth: a:opts.width,
            \ minheight: a:opts.height,
            \ zindex: 50,
            \ })
        call setwinvar(id, '&wincolor', a:hl)
        exe 'au BufWipeout * ++once call popup_close('..id..')'
        return winbufnr(id)
    else
        let buf = term_start(&shell, #{hidden: 1})
        call popup_create(buf, #{
            \ line: a:opts.line,
            \ col: a:opts.col,
            \ minwidth: a:opts.width,
            \ minheight: a:opts.height,
            \ zindex: 51,
            \ })
        exe 'au BufWipeout * ++once bw! '..buf
    endif
endfu

